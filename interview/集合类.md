# 简介
Java集合大致可以分为Set、List、Queue和Map四种体系。其中Set代表无序、不可重复的集合；List代表有序、重复的集合；Map则代表具有映射关系的集合。java5又增加了Queue体系集合，代表一种队列集合实现。
## java集合和数组的区别：
* 数组长度初始化时指定，意味着只能保存定长的数据。而集合可以保存数量不确定的数据。同时可以保存具有映射关系的数据。
* 数组元素既可以是基本数据类型的值，也可以是对象。但集合只能保存对象
## Set集合
Set集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个Set集合中，则添加操作失败，add()方法返回false,且新元素不会被加入。
## List集合
List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。
## Queue
队列通常是指"先进先出"的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入(offer)到队列的尾部，访问元素(poll)操作会返回队列头部的元素
## Map集合
Map保存具有映射关系的数据，因此Map集合里保存着两数组，一组保存Map里的key，另一组保存Map里的value。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较总是返回false。
### Map与Set、list关系
* 如果把Map里所有key放在一起看，它们组成了一个Set集合(所有key没有顺序，可以与key之间不能重复)，实际上Map确实包含了一个keySet()方法，返回Map里所有key组成的Set集合
* 如果把Map里的所有value放在一起来看，它们类似一个List：元素与元素之间可以重复，每个元素可以根据索引来查找，只是Map中索引不在使用整数值，而是以另外一个对象作为索引.
## ArrayList
以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。
* 按数组下标访问元素：get(i)/set(i,e)的性能很高。直接在数组末尾加入元素：add(e)的性能也高。
* 但如果按下标插入、删除元素:add(i,e),remove(i),remove(e),则要用System.arraycopy()来移动部分受影响的元素，性能就变差。
### 自动扩容机制
```java
  private void ensureCapacityInternal(int minCapacity){
    if(elementData==DEFUALTCAPACITY_EMPTY_ELEMENTDATA){
      minCapacity=Math.max(DEFAULT_CAPACITY,minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
  }
  private void ensureExplicitCapacity(int minCapacity){
    modCount++;
    if(minCapacity-elementData.length>0){
      grow(minCapacity);
    }
  }
  private void grow(int minCapacity){
    int oldCapacity=elementData.length;
    int newCapacity=oldCapacity+(oldCapacity>>1);
    if(newCapacity-minCapacity<0){
      newCapacity=minCapacity;
    }
    if(newCapacity-MAX_ARRAY_SIZE>0){
      newCapacity=hugeCapacity(minCapacity);
    }
    elementData=Arrays.copyOf(elementData,newCapacity);
  }
```
### get/set/remove
```java
  public E set(int index,E element){
    rangeCheck(index);
    E oldValue=elementData(index);
    elementData[index]=element;
    return oldValue;
  }
  public E get(int index){
    rangeCheck(index);
    return elementData(index);
  }
  public E remove(int index){
    rangeCheck(index);
    modCount++;
    E oldValue=elementData(index);
    int numMoved=size-index-1;
    if(numMoved>0){
      System.arraycopy(elementData,index+1,elementData,index,numMoved);
    }
    elementData[--size]=null;
    return oldValue;
  }
```
## LinkedList
以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。
* 按下标访问元素：get(i)/set(i,e)要悲剧的遍历链表将指针移动到位(如果i>数组大小的一半，会从末尾移起)
* 插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表两头的操作：add(),addFirst(),removeLast()或用iterator()上的remove()能省掉指针的移动。
### get/set方法
```java
  public E set(int index,E element){
    checkElementIndex(index);
    Node<E> x=node(index);
    E oldVal=x.item;
    x.item=element;
    return oldVal;
  }
  public E get(int index){
    checkElementIndex(index);
    return node(index).item;
  }
  Node<E> node(int index){
    if(index<(size>>1)){
      Node<E> x=first;
      for(int i=0;i<index;i++){
        x=x.next;
      }
      return x;
    }else{
      Node<E> x=last;
      for(int i=size-1;i>index;i--){
        x=x.prev;
      }
      return x;
    }
  }
```
## HashMap
基于Map接口实现，允许null键/值、非同步、不保证有序，也不保证序不随时间变化。
  1.什么时候会使用HashMap?它有什么特点？
  2.知道HashMap的工作原理么
  3.知道get和put原理么？equals()和hashCode()的都有什么作用？
  4.知道hash的实现么？为什么要这样实现？
  5.如果HashMap的大小超过负载因子定义的容量，怎么办
  
### put的实现
* 对key的hashCode()做hash，然后再计算index；
* 如果没碰撞直接放到bucket里
* 如果碰撞了，以链表的形式存在buckets后
* 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD),就把链表转换成红黑树；
* 如果节点已经存在就替换old value(保证key的唯一性)
* 如果bucket满了(超过load factor* current capacity)就要resize
```java
  public V put(K key,V value){
    //对key的hashCode()做hash
    return putVal(hash(key),key,value,false,true);
  }
  final V putVal(int hash, K key,V value,boolean onlyIfAbsent,boolean evict){
    Node<K,V>[] tab;
    Node<K,V> p;
    int n,i;
    //tab为空则创建
    if((tab=table)==null||(n=tab.length)==0){
      n=(tab=resize()).length;
    }
    //计算index,并对null做处理
    if((p=tab[i=n-1&hash])==null){
      tab[i]=newNode(hash,key,value,null);
    }else{
      Node<K,V> e;K k;
      //节点存在
      if(p.hash==hash&&((k=p.key)==key||(key!=null&&key.equals(k)))){
        e=p;
      }else if(p instanceof TreeNode){//该链为树
        e=((TreeNode<K,V>)p).putTreeVal(this,tab,hash,key,value);
      }else{//该链为链表
        for(int binCount=0;;++binCount){
          if((e=p.next)==null){
            p.next=newNode(hash,key,value,null);
            if(binCount>=TREEIFY_THRESHOLD-1){
              treeifyBin(tab,hash);
            }
             break;
          }
          if(e.hash==hash&&((k=e.key)==key||(key!=null&&key.equals(k)))){
            break;
          }
          p=e;
        }
      }
      //写入
      if(e!=null){
        V oldValue=e.value;
        if(!onlyIfAbsent||oldValue==null){
          e.value=value;
        }
        afterNodeAccess(e);
        return oldValue;
      }
    }
    ++modCount;
    if(++size>threshold){
      resize();
    }
    afterNodeInsertion(evict);
    return null;
  }

```
### get的实现
* bucket里的第一个节点，直接命中；
* 如果有冲突，则通过key.equals(k)去查找对应的entry。若为树，则在树中通过key.eqauls(k)查找，O(logn);若为链表，则在链表中通过key.equals(k)查找，O(n).
```java
  public V get(Object key){
    Node<K,V> e;
    return (e=getNode(hash(key),key))==null?null:e.value;;
  }
  final Node<K,V> getNode(int hash,Object key){
    Node<K,V>[] tab;Node<K,V> first,e;int n;K k;
    if((tab=table)!=null&&(n=tab.length)>0&&(first=tab[(n-1)&hash])!=null){
      //直接命中
      if(first.hash==hash&&((k=first.key)==key||(key!=null&&key.equals(k)))){
        return first;
      }
      //未命中
      if((e=first.next)!=null){
        //在树中get
        if(first instanceof TreeNode){
          return ((TreeNode<K,V>)first).getTreeNode(hash,key);
        }
        //在链表中get
        do{
          if(e.hash==hash&&((k=e.key)==key||(key!=null&&key.equals(k)))){
            return e;
          }while((e=e.next)!=null);
        }
      }
    }
    return null;
  }
```
### Hash的实现
  h=hashCode():1111 1111 1111 1111    1111 0000 1110 1010
  h2=h>>>16:   0000 0000 0000 0000    1111 1111 1111 1111
  hash=h^h2:   1111 1111 1111 1111    0000 1111 0001 0101
  (n-1):       0000 0000 0000 0000    0000 0000 0000 1111
  (n-1)&hash:  0000 0000 0000 0000    0000 0000 0000 0101
```java
  static final int hash(Object key){
    int h;
    return (key==null)?0:(h=key.hashCode())^(h>>>16);
  }
```
### resize的实现
当put时，发现目前的bucket占用程度已经超过Load Factor所希望的比例，那么就会发生resize。在resize过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。  
然而我们使用的是2次幂的扩展,所以元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置.
如果从16扩展为32时，
n-1:          0000 0000 0000 0000   0000 0000 0000 1111      1111 1111 1111 1111   0000 1111 0001 1111
hash1:        1111 1111 1111 1111   0000 1111 0000 0101  --> 1111 1111 1111 1111   0000 1111 0000 0101
(n-1)&hash1:  1111 1111 1111 1111   0000 1111 0001 0101      1111 1111 1111 1111   0000 1111 0001 0101

因此元素在重新计算hash之后，n变为2倍，那么n-1的mask范围在高位多1bit。因此在扩充HashMap的时候，不需要重新计算hash，只需要看原来的hash值新增的那个bit是1还是0就好。是0的话索引没变，是1的话索引变成"原索引+oldCapacity"
```java
  final Node<K,V>[] resize(){
    Node<K,V>[] oldTab=table;
    int oldCap=(oldTab==null)?0:oldTab.length;
    int oldThr=threshold;
    int newCap,newThr=0;
    if(oldCap>0){
      //超过最大值就不再扩充，就只好随你碰撞
      if(oldCap>=MAXIMUM_CAPACITY){
        threshold=Integer.MAX_VALUE;
        return oldTab;
      }else if((newCap=oldCap<<1)< MAXIMUM_CAPACITY&&oldCap>=DEFUALT_INITIAL_CAPACITY){
        newThr=oldThr<<1;
      }
    }else if(oldThr>0){
      newCap=oldThr;
    }else{
      newCap=DEFUALT_INITTIAL_CAPACITY;
      newThr=(int)(DEFUALT_LOAD_FACTOR*DEFUALT_INITIAL_CAPACITY);
    }
    //计算新的resize上限
    if(newThr==0){
      float ft=(float)newCap*loadFactor;
      newThr=(newCap<MAXIMUM_CAPACITY&&ft<(float)MAXIMUM_CAPACITY?(ft):Integer.MAX_VALUE)
    }
    threshold=newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
    Node<K,V>[] newTab=(Node<K,V>[])new Node[newCap];
    table=newTab;
    if(oldTab!=null){
      //把每个bucket都移动到新的buckets中
      for(int j=0;j<oldCap;++j){
        Node<K,V> e;
        if((e=oldTab[j])!=null){
          oldTab[j]=null;
          if(e.next==null){
            newTab[e.hash&(newCap-1)]=e;
          }else if(e instanceof TreeNode){
            ((TreeNode<K,V>)e.split(this,newTab,j,oldCap))
          }else{
            Node<K,V> loHead=null,loTail=null;
            Node<K,V> hiHead=null,hiTail=null;
            Node<K,V> next;
            do{
              next=e.next;
              //原索引
              if((e.hash&oldCap)==0){
                if(loTail==null){
                  loHead=e;
                }else{
                  loTail.next=e;
                }
                loTail=e;
              }else{//原索引+oldCap
                if(hiTail==null){
                  hiHead=e;
                }else{
                  hiTail.next=e;
                }
                hiTail=e;
              }
            }while((e=next)!=null);
            //原索引放到bucket里
            if(loTail!=null){
              loTail.next=null;
              newTab[j]=loHead;
            }
            //原索引+oldCap放到bucket里
            if(hiTail!=null){
              hiTail.next=null;
              newTab[j+oldCap]=hiHead;
            }
          }
        }
      }
    }
    return newTab;
  }
```
### 总结
1.什么时候使用HashMap？它有什么特点  
是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash,key,value,next)对象  
2.你知道HashMap的工作原理么  
通过hash的方法，通过put和get存储和获取对象。存储对象时，将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，hashMap会根据当前bucket的占用情况自动调整容量,为原来的2倍。获取对象时，将K传给get方法，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞，HashMap通过链表将产生碰撞冲突的元素组织起来。  
3.你知道get和put的原理么？equals()和hashCode()的都有什么作用  
通过对key的hashCode()进行hashing,并计算下标(n-1)&hash,从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点  
4.你知道hash的实现么？为什么要这样实现？  
通过hashCode()的高16位异或低16位实现的：(h=k.hashCode())^h>>>16,主要是从速度、功效、质量来考虑，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与hash的计算中，同时不会有太大的开销。  
5.如果HashMap的大小超过负载因子定义的容量，怎么办？  
会重新resize一个原来长度两倍的HashMap，并重新调用hash方法。

# TreeMap
HashMap不保证数据有序，LinkedHashMap保证数据可以保持插入顺序，而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap。
## 数据结构
                 4:政治(黑)
     2:数学(红)                6:地理(红)
1:语文(黑)   3:英语(黑)   5:历史(黑)      7:生物(黑)
                                            8:化学(红)
使用红黑树的好处是能够使得树具有不错的平衡性，这样操作的速度既可以达到log(n)的水平。
## put函数
如果存在的话，old value被替换；如果不存在，则新添一个节点，然后对做红黑树的平衡操作
```java
  public V put(K key,V value){
    Entry<K,V> t=root;
    if(t==null){
      compare(key,key);
      root=new Entry<>(key,value,null);
      size=1;
      modCount++;
      return null;
    }
    int cmp;
    Entry<K,V> parent;
    Comarator<? super K> cpr=comparator;
    //如果该节点存在，则替换值直接返回
    if(cpr!=null){
      do{
        parent=t;
        cmp=cpr.comapre(key,t.key);
        if(cmp<0){
          t=t.left;
        }else if(cmp>0){
          t=t.right;
        }else{
          return t.setValue(value);
        }
      }while(t!=null);
    }else{
      if(key==null){
        throw new NullPointerException();
      }
      @SuppressWarings("unchecked")
      Comparaable<? super K> k=(Comparable<? super K>)key;
      do{
        parent=t;
        cmp=k.compareTo(t.key);
        if(cmp<0){
          t=t.left;
        }else if(cmp>0){
          t=t.right;
        }else{
          return t.setValue(value);
        }
      }while(t!=null);
    }
    //如果该节点未存在，则新建
    Entry<K,V> e=new Entry<>(key,value,parent);
    if(cmp<0){
      parent.left=e;
    }else{
      parent.right=e;
    }
    //红黑树平衡调整
    fixAfterInsertion(e);
    size++;
    modCount++;
    return null;
  }
  
  private void fixAfterInsertion(TreeMapEntry<K,V> x){
    x.color=RED;
    while(x!=null&&x!=root&&x.parent.color==RED){
      if(parentOf(x)==leftOf(parentOf(parentOf(x)))){
        TreeMapEntry<K,V> y=rightOf(parentOf(parentOf(x)));
        if(colorOf(y)==RED){
          setColor(parentOf(x),BLACK);
          setColor(y,BLACK);
          setColor(parentOf(parentOf(x)),RED);
          x=parentOf(parentOf(x));
        }else{
          if(x==rightOf(parentOf(x))){
            x=parentOf(x);
            rotateLeft(x);
          }
          setColor(parentOf(x),BLACK);
          setColor(parentOf(parentOf(x)),RED);
          rotateRight(parentOf(parentOf(x)));
        }
      }else{
        TreeMapEntry<K,V> y=leftOf(parentOf(parentOf(x)));
        if(colorOf(y)==RED){
          setColor(parentOf(x),BLACK);
          setColor(y,BLACK);
          setColor(parentOf(parentOf(x)),RED);
          x=parentOf(parentOf(x));
        }else{
          if(x==leftOf(parentOf(x))){
            x=parentOf(x);
            rotateRight(x);
          }
          setColor(parentOf(x),BLACK);
          setColor(parentOf(parentOf(x)),RED);
          rotateLeft(parentOf(parentOf(x)));
        }
      }
    }
    root.color=BLACK;
  }
  
  private static<K,V> TreeMapEntry<K,V> parentOf(TreeMapEntry<K,V> p){
    return(p==null?null:p.parent);
  }
```
## get函数
以log(n)的复杂度进行get
```java
  final Entry<K,V> getEntry(Object key){
    if(comparator!=null){
      return getEntryUsingComparator(key);
    }
    if(key==null){
      throw new NullPointerException();
    }
    @SuppressWarnings("unchecked")
    Comparable<? super K> k=(Comparable<? super K>)key;
    Entry<K,V> p=root;
    while(p!=null){
      int cmp=k.compareTo(p.key);
      if(cmp<0){
        p=p.left;
      }else if(cmp>0){
        p=p.right;
      }else{
        return p;
      }
    }
    return null;
  }
  
  public V get(Object key){
    Entry<K,V> p=getEntry(key);
    return (p==null?null:p.value);
  }
```
## successor后继
TreeMap是如何保证其迭代输出是有序的？从宏观上讲，就相当于树的中序遍历(LDR)。
```java
  for(Iterator<Map.Entry<String,String>> it=tmap.entrySet().iterator();tmap.hasNext();){
    Entry<Integer,String> entry=it.next();
    System.out.println(entry.getKey()+":"+entry.getValue());
  }
```
在it.next()的调用中会使用nextEntry调用successor这个是过的后继的重点：
```java
  static <K,V> TreeMap.Entry<K,V> successor(Entry<K,V> t){
    if(t==null){
      return null;
    }else if(t.right!=null){
      //有右子树的节点，后继节点就是右子树的"最左节点"
      //因为"最左子树"是右子树的最小节点
      Entry<K,V> p=t.right;
      while(p.left!=null){
        p=p.left;
      }
      return p;
    }else{
      //如果右子树为空，则寻找当前节点所在左子树的第一个祖先节点
      //因为左子树找完了，根据LDR该D了
      Entry<K,V> p=t.parent;
      Entry<K,V> ch=t;
      //保证左子树
      while(p!=null&&ch==p.right){
        ch=p;
        p=p.parent;
      }
      return p；
    }
  }
```
中序遍历，L-D-R:
  a.空节点，没有后继
  b.有右子树的节点，后继就是右子树的"最左节点"
  c.无右子树的节点，后继就是该节点所在左子树的第一个祖先节点






































