# 简介
Java集合大致可以分为Set、List、Queue和Map四种体系。其中Set代表无序、不可重复的集合；List代表有序、重复的集合；Map则代表具有映射关系的集合。java5又增加了Queue体系集合，代表一种队列集合实现。
## java集合和数组的区别：
* 数组长度初始化时指定，意味着只能保存定长的数据。而集合可以保存数量不确定的数据。同时可以保存具有映射关系的数据。
* 数组元素既可以是基本数据类型的值，也可以是对象。但集合只能保存对象
## Set集合
Set集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个Set集合中，则添加操作失败，add()方法返回false,且新元素不会被加入。
## List集合
List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。
## Queue
队列通常是指"先进先出"的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入(offer)到队列的尾部，访问元素(poll)操作会返回队列头部的元素
## Map集合
Map保存具有映射关系的数据，因此Map集合里保存着两数组，一组保存Map里的key，另一组保存Map里的value。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较总是返回false。
### Map与Set、list关系
* 如果把Map里所有key放在一起看，它们组成了一个Set集合(所有key没有顺序，可以与key之间不能重复)，实际上Map确实包含了一个keySet()方法，返回Map里所有key组成的Set集合
* 如果把Map里的所有value放在一起来看，它们类似一个List：元素与元素之间可以重复，每个元素可以根据索引来查找，只是Map中索引不在使用整数值，而是以另外一个对象作为索引.
## ArrayList
以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。
* 按数组下标访问元素：get(i)/set(i,e)的性能很高。直接在数组末尾加入元素：add(e)的性能也高。
* 但如果按下标插入、删除元素:add(i,e),remove(i),remove(e),则要用System.arraycopy()来移动部分受影响的元素，性能就变差。
### 自动扩容机制
```java
  private void ensureCapacityInternal(int minCapacity){
    if(elementData==DEFUALTCAPACITY_EMPTY_ELEMENTDATA){
      minCapacity=Math.max(DEFAULT_CAPACITY,minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
  }
  private void ensureExplicitCapacity(int minCapacity){
    modCount++;
    if(minCapacity-elementData.length>0){
      grow(minCapacity);
    }
  }
  private void grow(int minCapacity){
    int oldCapacity=elementData.length;
    int newCapacity=oldCapacity+(oldCapacity>>1);
    if(newCapacity-minCapacity<0){
      newCapacity=minCapacity;
    }
    if(newCapacity-MAX_ARRAY_SIZE>0){
      newCapacity=hugeCapacity(minCapacity);
    }
    elementData=Arrays.copyOf(elementData,newCapacity);
  }
```
### get/set/remove
```java
  public E set(int index,E element){
    rangeCheck(index);
    E oldValue=elementData(index);
    elementData[index]=element;
    return oldValue;
  }
  public E get(int index){
    rangeCheck(index);
    return elementData(index);
  }
  public E remove(int index){
    rangeCheck(index);
    modCount++;
    E oldValue=elementData(index);
    int numMoved=size-index-1;
    if(numMoved>0){
      System.arraycopy(elementData,index+1,elementData,index,numMoved);
    }
    elementData[--size]=null;
    return oldValue;
  }
```
## LinkedList
以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。
* 按下标访问元素：get(i)/set(i,e)要悲剧的遍历链表将指针移动到位(如果i>数组大小的一半，会从末尾移起)
* 插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表两头的操作：add(),addFirst(),removeLast()或用iterator()上的remove()能省掉指针的移动。
### get/set方法
```java
  public E set(int index,E element){
    checkElementIndex(index);
    Node<E> x=node(index);
    E oldVal=x.item;
    x.item=element;
    return oldVal;
  }
  public E get(int index){
    checkElementIndex(index);
    return node(index).item;
  }
  Node<E> node(int index){
    if(index<(size>>1)){
      Node<E> x=first;
      for(int i=0;i<index;i++){
        x=x.next;
      }
      return x;
    }else{
      Node<E> x=last;
      for(int i=size-1;i>index;i--){
        x=x.prev;
      }
      return x;
    }
  }
```
## HashMap
基于Map接口实现，允许null键/值、非同步、不保证有序，也不保证序不随时间变化。
  1.什么时候会使用HashMap?它有什么特点？
  2.知道HashMap的工作原理么
  3.知道get和put原理么？equals()和hashCode()的都有什么作用？
  4.知道hash的实现么？为什么要这样实现？
  5.如果HashMap的大小超过负载因子定义的容量，怎么办
  
### put的实现
* 对key的hashCode()做hash，然后再计算index；
* 如果没碰撞直接放到bucket里
* 如果碰撞了，以链表的形式存在buckets后
* 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD),就把链表转换成红黑树；
* 如果节点已经存在就替换old value(保证key的唯一性)
* 如果bucket满了(超过load factor* current capacity)就要resize
```java
  public V put(K key,V value){
    //对key的hashCode()做hash
    return putVal(hash(key),key,value,false,true);
  }
  final V putVal(int hash, K key,V value,boolean onlyIfAbsent,boolean evict){
    Node<K,V>[] tab;
    Node<K,V> p;
    int n,i;
    //tab为空则创建
    if((tab=table)==null||(n=tab.length)==0){
      n=(tab=resize()).length;
    }
    //计算index,并对null做处理
    if((p=tab[i=n-1&hash])==null){
      tab[i]=newNode(hash,key,value,null);
    }else{
      Node<K,V> e;K k;
      //节点存在
      if(p.hash==hash&&((k=p.key)==key||(key!=null&&key.equals(k)))){
        e=p;
      }else if(p instanceof TreeNode){//该链为树
        e=((TreeNode<K,V>)p).putTreeVal(this,tab,hash,key,value);
      }else{//该链为链表
        for(int binCount=0;;++binCount){
          if((e=p.next)==null){
            p.next=newNode(hash,key,value,null);
            if(binCount>=TREEIFY_THRESHOLD-1){
              treeifyBin(tab,hash);
            }
             break;
          }
          if(e.hash==hash&&((k=e.key)==key||(key!=null&&key.equals(k)))){
            break;
          }
          p=e;
        }
      }
      //写入
      if(e!=null){
        V oldValue=e.value;
        if(!onlyIfAbsent||oldValue==null){
          e.value=value;
        }
        afterNodeAccess(e);
        return oldValue;
      }
    }
    ++modCount;
    if(++size>threshold){
      resize();
    }
    afterNodeInsertion(evict);
    return null;
  }

```
### get的实现
* bucket里的第一个节点，直接命中；
* 如果有冲突，则通过key.equals(k)去查找对应的entry。若为树，则在树中通过key.eqauls(k)查找，O(logn);若为链表，则在链表中通过key.equals(k)查找，O(n).
```java
  public V get(Object key){
    Node<K,V> e;
    return (e=getNode(hash(key),key))==null?null:e.value;;
  }
  final Node<K,V> getNode(int hash,Object key){
    Node<K,V>[] tab;Node<K,V> first,e;int n;K k;
    if((tab=table)!=null&&(n=tab.length)>0&&(first=tab[(n-1)&hash])!=null){
      //直接命中
      if(first.hash==hash&&((k=first.key)==key||(key!=null&&key.equals(k)))){
        return first;
      }
      //未命中
      if((e=first.next)!=null){
        //在树中get
        if(first instanceof TreeNode){
          return ((TreeNode<K,V>)first).getTreeNode(hash,key);
        }
        //在链表中get
        do{
          if(e.hash==hash&&((k=e.key)==key||(key!=null&&key.equals(k)))){
            return e;
          }while((e=e.next)!=null);
        }
      }
    }
    return null;
  }
```
### Hash的实现
  h=hashCode():1111 1111 1111 1111    1111 0000 1110 1010
  h2=h>>>16:   0000 0000 0000 0000    1111 1111 1111 1111
  hash=h^h2:   1111 1111 1111 1111    0000 1111 0001 0101
  (n-1):       0000 0000 0000 0000    0000 0000 0000 1111
  (n-1)&hash:  0000 0000 0000 0000    0000 0000 0000 0101
```java
  static final int hash(Object key){
    int h;
    return (key==null)?0:(h=key.hashCode())^(h>>>16);
  }
```
### resize的实现
当put时，发现目前的bucket占用程度已经超过Load Factor所希望的比例，那么就会发生resize。在resize过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。  
然而我们使用的是2次幂的扩展,所以元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置.
如果从16扩展为32时，
n-1:          0000 0000 0000 0000   0000 0000 0000 1111      1111 1111 1111 1111   0000 1111 0001 1111
hash1:        1111 1111 1111 1111   0000 1111 0000 0101  --> 1111 1111 1111 1111   0000 1111 0000 0101
(n-1)&hash1:  1111 1111 1111 1111   0000 1111 0001 0101      1111 1111 1111 1111   0000 1111 0001 0101

因此元素在重新计算hash之后，n变为2倍，那么n-1的mask范围在高位多1bit。因此在扩充HashMap的时候，不需要重新计算hash，只需要看原来的hash值新增的那个bit是1还是0就好。


















